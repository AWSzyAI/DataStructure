1. 假设以邻接表表示法作为图的存储结构，设计图的深度优先遍历递归算法。

    > 思路：遍历每个连通分量，在连通分量中；一边遍历一边打标记即可
    >
    > 时间复杂度：$O(n+e)$

     ```c++
     template<class T>
     void ALGraph<T>::dfs() {
         // 辅助变量
     	vector<bool> vis(n + 1, false);
     
         // 深搜函数
     	function<void(int, vector<bool>&)> dfs = [&](int now, vector<bool>& vis) {
     		cout << now << " ";
     		vis[now] = true;
     		for (EdgeNode<T>* p = h[now].next; p; p = p->next) {
     			if (!vis[p->toid]) {
     				dfs(p->toid, vis);
     			}
     		}
     	};
     
         // 调用
     	for (int i = 1; i <= n; i++) {
     		if (!vis[i]) {
     			dfs(i, vis);
     		}
     	}
     }
     ```

2. 试基于图的广度优先搜索策略编写一算法，判别以邻接表方式存储的有向图中是否存在由顶点 $v_i$ 到顶点 $v_j$ 的路径 $(i\ne j)$。

    > 思路：其实就是 $bfs$ 遍历图即可，然后判断是否从 $v_i$ 开始能够遍历到 $v_j$
    >
    > 注意点：
    >
    > 1. 与树的 $bfs$ 的区别
    >
    >     - 树的 $bfs$ 遍历不需要标记当前结点是否遍历过，因为不会对后续的遍历产生影响 - 由于树的特性（特殊的有向无环图）当前结点不会再遍历到之前已经遍历过的结点
    >
    >     - 图的 $bfs$ 遍历需要标记当前结点是否遍历过，因为环的原因，就需要打标记，否则就会出错
    >
    > 2. $bfs$ 时，图上标记的时机
    >
    >     - 出队需要打标记
    >     - 入队也需要打标记
    >
    > 时间复杂度：$O(n+e)$

    ```c++
    template<class T>
    bool ALGraph<T>::FindPathFromA2B(int a, int b) {
    	// 越界判断
    	if (a < 1 || a > n || b < 1 || b > n) {
    		cerr << "Wrong Input! Out of Range!\n";
    		exit(1);
    	}
    
    	// 辅助变量
    	vector<bool> vis(n + 1, false);
    	bool ok = false;
    
    	// 宽搜函数
    	auto bfs = [&](int hh) {
    		queue<int> q;
    		q.push(hh);
    
    		while (q.size()) {
    			auto now = q.front();
    			q.pop();
    			vis[now] = true;
    
    			// 搜到路径了直接结束搜索
    			if (now == b) {
    				ok = true;
    				break;
    			}
    
    			for (EdgeNode<T>* p = h[now].next; p; p = p->next) {
    				if (!vis[p->toid]) {
    					vis[p->toid] = true; // 与树的bfs唯一的不同
    					q.push(p->toid);
    				}
    			}
    		}
    	};
    
    	// 调用过程并返回答案
    	bfs(a);
    	return ok;
    }
    ```

    
