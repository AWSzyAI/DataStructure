1. 若一棵*m*叉树中，度为1的结点有*N*1个，度为2的结点有*N*2个，……，度为*m*的结点有*Nm*个，问该树的叶子结点有多少个？

    已知树的结点数为 $n$，边数为 $m$，则
    $$
    n=m+1
    $$
    叶子结点的个数 $res_{leaf}$，即 $N_0$ 为：
    $$
    N_0=n-(N_1+N_2+\cdots+N_m)
    $$
    而 $n$ 为：
    $$
    n=(1N_1+2N_2+\cdots+mN_m)+1
    $$
    于是 $N_0$ 为：
    $$
    N_0=N_2+2N_3+\cdots+(m-1)N_m+1
    $$

2. 试找出分别满足下列条件的所有二叉树： （此题在纸上画，不用提交）
    （1）先序序列和中序序列相同；
    （2）中序序列和后序序列相同；
    （3）先序序列和后序序列相同。

  这道题一开始可能没什么思路，也许可以随意画几个结点凑数，但是没有一般的结论。在此，我推导出了一个结论：

  首先我们知道：

  - 先序遍历：根左右
  - 中序遍历：左根右
  - 后序遍历：左右根

  接着我们从遍历顺序入手：

  （1）先序 == 中序 $\to$ 根左右 == 左根右

  我们知道，对于一棵根树，根首先是不可以丢掉的，那么如果想要上式成立，**在保留尽可能多的结点的情况下**，我们只需要保留“根右”两个部分，就可以满足上述条件。

  于是最终画出来的二叉树就是：对于每一个结点，都只有右子树。

  （2）中序 == 后序 $\to$ 左根右 == 左右根

  同样的思路，**在保留尽可能多的结点的情况下**，我们只需要保留“左根”两个部分，就可以满足上述条件。

  于是最终画出来的二叉树就是：对于每一个结点，都只有左子树。

  （3）先序 == 后序 $\to$ 根左右 == 左右根

  同样的思路，**在保留尽可能多的结点的情况下**，我们只能保留”根“一个部分。

  于是最终画出来的二叉树就是：只有一个根结点。

3. 设有168个结点的完全二叉树，请问叶子结点、单分支结点、双分支结点各有多少个？

    - 首先我们计算当前完全二叉树的层数 $t=\left \lceil \log_2(N+1) \right \rceil=8$

    - 前7层是满二叉树，共 $2^7-1=127$ 个结点
    - 第7层是特殊结点，我们计算其结点总数为 $2^6=64$ 个结点
    - 第8层是从左到右排布的结点，共 $168-127=41$ 个结点

    于是我们就可以计算出：

    - 双分支结点为 $127-64+ \left \lfloor \frac{41}{2} \right \rfloor=83$ 个
    - 单分支结点为 $41\%2=1$ 个
    - 叶子结点为 $41+64-\left \lceil \frac{41}{2} \right \rceil=84$ 个，验算为 $168-83-1=84$ 个

4. 已知某二叉树的后序序列是*GEFCDBA*，中序序列是*AEGCFBD*，请画出该二叉树的二叉链表结构图，并写出先序遍历序列。

    <img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231107144008995.png" alt="image-20231107144008995" style="zoom:15%;" />

5. 试编写算法求二叉树中双分支节点的个数。

    > 思路：遍历每一个结点进行判断即可
    >
    > 时间复杂度：$O(n)$

    ```c++
    int CountTwobranch(BTree<char>& tree) {
        function<void(BtNode<char>*, int&)> dfs = [&](BtNode<char>* now, int& res) -> void {
            if (!now) {
                return;
            }
            if (now->lchild && now->rchild) {
                res++;
            }
            dfs(now->lchild, res);
            dfs(now->rchild, res);
        };
    
        int res = 0;
        dfs(tree.root, res);
        return res;
    }
    ```

6. 试编写算法求二叉树中各个结点的平衡因子（左右子树高度之差）

    > 思路：对于每一个结点，我们单独计算其左右子树的高度差即可
    >
    > 时间复杂度：$O(n^2)$

    ```c++
    vector<pair<string, int>> CalcHeightSub(BTree<char>& tree) {
        // 计算当前结点到叶子结点的最远距离
        function<int(BtNode<char>*)> Depth = [&](BtNode<char>* now) -> int {
            if (!now) {
                return 0;
            }
            return max(Depth(now->lchild), Depth(now->rchild)) + 1;
        };
    
        // 计算每一个结点的左右子树的高度差
        function<void(BtNode<char>*, vector<pair<string, int>>&)> dfs = [&](BtNode<char>* now, vector<pair<string, int>>& res) -> void {
            if (!now) {
                return;
            }
            res.push_back({to_string(now->data) + ":", abs(Depth(now->lchild) - Depth(now->rchild))});
            dfs(now->lchild, res);
            dfs(now->rchild, res);
        };
    
        vector<pair<string, int>> res;
        dfs(tree.root, res);
        return res;
    }
    ```

7. 一棵二叉树以二叉链表来表示，求其指定的某一层k(k>1)上的叶子结点的个数。

    > 思路：直接遍历这棵树，增加参数为当前的层数，若当前层数为 $k$ 且当前结点为叶子结点，则答案加1
    >
    > 时间复杂度：$O(n)$

    ```c++
    int CountKLevel(BTree<char>& tree, int k) {
        function<void(BtNode<char>*, int, int&)> dfs = [&](BtNode<char>* now, int dep, int& res) -> void {
            if (!now) {
                return;
            }
            if (dep == k) {
                res++;
            }
            dfs(now->lchild, dep + 1, res);
            dfs(now->rchild, dep + 1, res);
        };
    
        int res = 0;
        dfs(tree.root, 0, res);
        return res;
    }
    ```

8. 试编写算法输出一棵二叉树中根结点到各个叶子结点的路径。

    > 思路：首先显然我们需要将答案定义为一个二维数组表示根结点到所有的叶子结点的路径，那么关键在于如何求出每一个路径。在这里我们采用保留路径的方式，即我们开一个路径数组用来记录当前路径的情况，如果当前是结点，则 `push_back()`，如果是叶子结点，就将当前的路径 `path` 存入答案。在回溯的时候及时将当前结点清除，即 `pop_back()` 即可。
    >
    > 时间复杂度：$O(n)$

     ```c++
     vector<vector<char>> PathOfRoot2Leaf(BTree<char>& tree) {
         function<void(BtNode<char>*, vector<vector<char>>&, vector<char>&)> dfs = [&](BtNode<char>* now, vector<vector<char>>& res, vector<char>& path) ->void {
             if (!now) {
                 return;
             }
             path.push_back(now->data);
             if (!now->lchild && !now->rchild) {
                 res.push_back(path);
             }
             dfs(now->lchild, res, path);
             dfs(now->rchild, res, path);
             path.pop_back();
         };
     
         vector<vector<char>> res;
         vector<char> path;
         dfs(tree.root, res, path);
         return res;
     }
     ```

9. 设计一个算法，求二叉树中两个给定结点的最近公共祖先。

     

10. 若一棵二叉树中没有数据域值相同的结点，试设计算法打印二叉树中数据域值为x的结点的所有祖先结点的数据域。如果根结点的数据域值为x或不存在数据域值为x的结点，则什么也不打印。例如对下图所示的二叉树，则打印结点序列为A、C、E。

    ![img](file:///C:/Users/董文杰/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png)
    
    > 思路：和T8类似，只是标记点为指定的点而非叶子结点
    >
    > 时间复杂度：$O(n)$
    
    ```c++
    vector<char> PathOfRoot2X(BTree<char>& tree, char x) {
        vector<char> res, path;
    
        function<void(BtNode<char>*, vector<char>&)> dfs = [&](BtNode<char>* now, vector<char>& path) {
            if (!now) {
                return;
            }
            path.push_back(now->data);
            if (now->data == x) {
                path.pop_back();
                res = path;
            }
            dfs(now->lchild, path);
            dfs(now->rchild, path);
            path.pop_back();
        };
    
        dfs(tree.root, path);
        return res;
    }
    ```
